// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------


// -----------------------------------------
// Mathematical definition of n^e
function math_pow(n: Int, e: Int): Int
    requires 0 <= e
{
    e == 0 ? 1 : n * math_pow(n, e - 1)
}
// -----------------------------------------

// -----------------------------------------
// You can use this lemma without a proof
method lemma_pow(b: Int, y: Int) 
    requires 0 <= y
    requires y % 2 == 0 // y is even
    ensures math_pow(b, y) == math_pow(b * b, y / 2)

// Lemma for odd case
method lemma_pow_odd(b: Int, y: Int, res: Int, target: Int)
    requires 0 < y
    requires y % 2 == 1 // y is odd
    requires res * math_pow(b, y) == target
    ensures (res * b) * math_pow(b * b, y / 2) == target
// -----------------------------------------

// -----------------------------------------
// Helper function to calculate the number of iterations needed
// This equals floor(log2(e)) + 1, which is the number of times
// we can divide e by 2 until we reach 0
function iterations_needed(e: Int): Int
    requires 0 < e
    ensures result >= 1
{
    e == 1 ? 1 : 1 + iterations_needed(e / 2)
}
// -----------------------------------------


// -----------------------------------------
// Task 2: Prove a runtime bound for the following recursive method
// Your bound should be tight, i.e. use as few time credits
// as possible. Furthermore, try to prove that it is not possible
// to use fewer time credits.
// Do not modify the given production code. However, feel free to 
// introduce additional functions, lemma methods or ghost code.
// Furthermore, make sure that the functional contract remains intact.
method fast_pow(n: Int, e: Int)
    returns (res: Int)
    requires 0 < e
    // TODO: verify; add time credits and runtime bounds
    // Time credits: 1 for method call + iterations_needed(e) for loop iterations
    requires acc(time_credit(), (1 + iterations_needed(e))/1)
    ensures res == math_pow(n, e)
{
    consume_time_credit() // we must spend a credit for every call

    var b: Int := n
    var y: Int := e 
    res := 1

    while (y > 0)
        // Loop invariant: the product res * b^y equals n^e (functional correctness)
        invariant 0 <= y
        invariant res * math_pow(b, y) == math_pow(n, e)
        // Time credit invariant: we have enough credits for remaining iterations
        // When y > 0, we need iterations_needed(y) credits; when y == 0, we need none
        invariant y > 0 ==> acc(time_credit(), iterations_needed(y)/1)
    {
        consume_time_credit() // we must spend a credit for every loop iteration
        
        if (y % 2 == 1) {
            // Odd case
            lemma_pow_odd(b, y, res, math_pow(n, e))
            res := res * b
        } else {
            // Even case
            lemma_pow(b, y)
        }
        
        y := y / 2
        b := b * b
    }
}
// -----------------------------------------

// -----------------------------------------
// PROOF THAT THE BOUND IS TIGHT
// The runtime bound 1 + iterations_needed(e) is tight because:
// 1. We always execute the method call: 1 credit
// 2. The loop runs exactly iterations_needed(e) times because:
//    - Each iteration halves y (via y := y / 2)
//    - We continue until y becomes 0
//    - iterations_needed(e) = floor(log2(e)) + 1 is the exact number of halvings
// 3. Examples:
//    - e=1: iterations_needed(1) = 1, loop runs 1 time (y: 1→0)
//    - e=2: iterations_needed(2) = 2, loop runs 2 times (y: 2→1→0)
//    - e=3: iterations_needed(3) = 2, loop runs 2 times (y: 3→1→0)
//    - e=4: iterations_needed(4) = 3, loop runs 3 times (y: 4→2→1→0)
//    - e=7: iterations_needed(7) = 3, loop runs 3 times (y: 7→3→1→0)
//    - e=8: iterations_needed(8) = 4, loop runs 4 times (y: 8→4→2→1→0)
// 4. This is optimal: O(log e) is the best possible for exponentiation by squaring
// 5. Using fewer credits would fail verification - the loop invariant on time_credit
//    ensures we have exactly iterations_needed(y) credits at the start of each iteration
// -----------------------------------------